---
title: "Lab Notebook no. 2"
subtitle: "CSCI 3141: Foundations of Data Science Using R"
output: html_notebook
---

This Lab Guide is based on materials authored by Dr. Luís Torgo, modified with his permission, and made available for your personal educational use only..


-----

# Purpose

This is an introduction to using the R language in the RStudio environment. The explanations and examples in this guide will help you learn how to use the R language to accomplish simple tasks.

# Task

Read this notebook carefully and run each code chunk as it appears. Do not limit yourself to that. Add code chunks, test your own code alternatives, and play around with the code. Making mistakes will help you make better use of this lab and learn faster.

You can (and should) refer to [this Base R cheatsheet](https://paulvanderlaken.files.wordpress.com/2017/08/base-r-cheetsheat.pdf) and/or [this R Reference Card](https://cran.r-project.org/doc/contrib/Baggott-refcard-v2.pdf) whenever you need it, today or at any point in the future. 

If you're using RStudio as recommended, you might also want to take a look at [this RStudio Cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/rstudio-ide.pdf).


# Criteria

This lab notebook will not be graded, but you must submit it to Brightspace by the end of this week to get participation points.

------

# Introduction

There are different kinds of files you can use to save your R code. This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. 
You can also use an R script to save your code.

## R Notebooks

R notebooks include text written in markdown (Check out the Markdown Quick Reference by clicking *Help > Markdown Quick Reference*), and code chunks that can be used to run R code. Each notebook is connected to a rendered HTML notebook file with the same name and extension *.nb.html*.

Every time you save this *.Rmd* file, the *.nb.html* connected to it is updated to reflect the current content of the notebook, including text, code, and any output that you generated by running code (for example, the results of a mathematical operation, or a graph).

**1. Execute the code** by clicking the *Run* button within the chunk of code below, or placing your cursor inside the code chunk and pressing *Ctrl+Shift+Enter*. The results will appear below.


```{r}
print("Hello World!")
```


**2. Preview** the rendered HTML document generated by this notebook by clicking *Preview \> Preview Notebook* (or by pressing *Ctrl+Shift+K*). Try also clicking on the little cog next to it and selecting *Preview in Viewer Pane*.

*Previewing the notebook will not run any code*; it simply displays the current content of the editor as it was last run.

**3. Clear the output** of our first chunk by clicking the little cross on the top right of the output box, and save. Now look at the preview pane: our printed message should have disappeared!

**4. Add a new chunk** by clicking the *Insert Chunk* button (or pressing *Ctrl+Alt+I*). Experiment with this new chunk by writing `plot(iris)` inside it, and running it. A plot should appear beneath it.

```{r}
plot(iris)

```

## R Scripts

Sometimes, we don't need the complexity (and possible messiness) of an R notebook. R notebooks are great for exploration, visualizations, and writing reports (or lab notes!). But, since you can jump around, running code chunks out of order, that can harm reproducibility. Remember that the last run of each chunk will be the one that gets saved even if the fourth chunk was run before the second one. This is not always a problem, but it can be. If you just want to save code, an R script might be all you need. 

In an R script, you don't need to insert code chunks. Everything that is on the file is assumed to be code, unless you start the line with a `#` (which turns that line of code into a comment). 

Next, we will create and save an example R script.
But first, let's plot a different data set **using the console**. 

**1. Write `plot(cars)` into the console, and execute this command by pressing *Enter***. The graph should appear in the plot viewer pane instead of within this notebook. This is what will  happen when you run code from a script as well.

**2. Create an example R script**. Write or copy-and-paste the lines of code you have encountered so far into it. If you click the *Run* button in the toolbar, the code region where your cursor is placed will run in the console. 

**3. Run the whole script** from start to finish by clicking on the *Source* button in the toolbar, or by executing the command `source("example_script.R")` after saving the file as `example_script.R`.

Let's move on to the basics of the R language. 

# R packages

Any base installation of R already comes with a series of installed packages.
A package is a set of functions and data that someone has made available to the community in a free and open source way.

Anyone can create a package and submit it to the R web site. A series of tests need to be overcome for the package to be officially posted in the CRAN website.

On top of the packages included in a R base installation you may install many other extra packages using the function `install.packages()`, like in the following example:

```{r}
install.packages("DMwR2")
```

After this installation (done once), you can load the package using the `library()` function to access all the functions contained in it.

```{r}
library(DMwR2)
```

You can also use specific functions in a library even before loading it by specifying the name of the package, followed by `::` and the function.

```{r}
DMwR2::centralValue(c(1,2,3))
```


# Basic data types

R objects may store a diverse type of information.

- Numbers: e.g., 5, 6.3, 10.344, -2.3, -7
- Strings: "hello", 'my name is Ana', "CSCI 3141"
- Logical values: TRUE, FALSE, T, F

In R, you can use `""` or `''` to make something a string. You can check if something is a string with the function `is.character()`.

R also includes a different data type called a factor, which you will learn about later, that uses strings as labels.

You can check if something is a number with the function `is.numeric()`, and if something is a Boolean value with `is.logical()`.

# Variables

Assignment of values to a variable in R is usually done with an "<-" (though the more common "=" also works).

R is *case-sensitive*! `TRUE` is a logical value; `true` is the name of a variable

```{r}
x <- true
x
```

If you are not finding a variable it may be that you stored it slightly differently.

```{r}
varX <- 27

varx
```

You can list the objects in your environment using the `ls()` function:

```{r}
ls()
```

Assignment is *destructive*. If we assign a value to a variable and this variable was storing something else, this latter value is "lost",

**1. Store a temperature value in Fahrenheit on a variable.** Store on another variable the equivalent temperature in Celsius. (In case you do not remember the conversion formula search Wikipedia)

```{r}

```

# Functions

## Getting Help

You can get help about any function in R by typing its name preceded by a "question mark `?` in the command line, and pressing `Enter`.

**1. Get help** about the `print()` function, or any other function you are curious about. 

## Creating Functions

To create a function in R you use the assignment operator to assign it to its function name:

```{r}
Cel2Fahr <- function(celsius) celsius * 9/5 + 32
```

**1.** Based on the above example, **create a function** to convert from Fahrenheit to Celsius.

```{r}
Fahr2Cel <- 
```

R is a functional language and we will use *function composition* extensively as a form of performing several complex operations without having to store every intermediate result.

**2. Test your function** by executing the following code. This line of code should convert the results of converting the temperature from Celsius to Fahrenheit back to Fahrenheit, so the output should be the same as what you assign to variable `x`.

```{r}
x <- 27

Fahr2Cel(Cel2Fahr(x))
```

If your function has more than one line, you have to use curly brackets `{}` to enclose the code.

```{r}
bigFunction <- function(x){
 # your code here
} 
```

The output of the last line will be the output returned by the function, unless you use the `return()` function before then.

```{r}
is.even <- function(x){
  if(!is.numeric(x)){
    print("x must be a number")
    return(NULL)
  }
  
  ifelse(x %% 2 == 0, "even", "odd")
}
```

(Bonus: get help about functions `is.numeric()` and `ifelse()` by typing `?is.numeric` and `?ifelse` in the command line and executing them.)

**3. Run the following code chunks** and try to understand what's happening.

```{r}
x <- is.even("a")
```

```{r}
print(x)
```


```{r}
is.even(27)
```

You can see the code for a function by typing its name in the command line without the brackets `()` or any arguments.

**4.Take a look at the code for function** `ifelse` by simply typing `ifelse` in the command line and pressing `Enter`. You don't need to understand it, but sometimes it's useful to be able to see a function's code.

# Vectors

The concatenate function `c()` can be used to create a vector with the elements we provide as arguments. 
These elements must be of the same data type. 

**1. Try to create a vector mixing strings with numbers** and understand what happens.

```{r}

```


## Basic Indexing

Unlike many other languages where vector indexing starts at 0, positions indices in R start with position number 1. 


```{r}
nStudents <- c(35, 12, 7)
```

**1. Run the following chunks of code** and see what happens.

```{r}
nStudents[1]
```

```{r}
nStudents[0]
```

You can associate names with each value of the vector to make the vector more readable. 

```{r}
names(nStudents) <- c("CompSci", "Physics", "Bioinformatics")
nStudents
```

This can make it easier to access certain values, as you can use the names to index the vector, instead of a numerical position.

Alternatively, the names can be set from the start when you create your vector.

```{r}
nStudents <- c(CompSci = 35, Physics = 5, Bioinformatics = 7, Neuroscience = 9)
```

Besides being more readable, the use of names has other advantages because R often ``silently" takes advantage of these names. 

**2. Get the number** of Physics students from the vector in two different ways.

```{r}

```

**2a. Run the following chunk.** Why does it fail? Fix it so you get the number of Physics students.

```{r}
nStudents[Physics]
```


**3. Plot the number of students per major** using the function `barplot()`.

```{r}

```


**3a. (Bonus) Give the graph a title and add a label for the X-axis** by exploring the help page of the function.

```{r}

```

You can use a vector of indices (or names) to access multiple values at a time.

**5. Try** running the following code

```{r}
nStudents[c(2, "Bioinformatics")]
```

**5a.** What happens? Why do you think it happens? 
(Hint: paste the vector used for indexing in the console and inspect the result.)

**5b.** Fix it so you get the number of Physics *and* Bioinformatics students.

All these indexing operations can be used to change particular elements of an existing vector. 

Suppose the number of Physics students enrolled in the course is actually zero. You can change it in the vector without creating a new one by executing the following code:

```{r}
nStudents["Physics"] <- 0
nStudents
```

You can use logical operations to index the vector as well.
- operator `&` for logical AND,
- operator `|` for logical OR,
- operator `!` for logical NOT.
You can see more of them on the R reference card.

Let's get the data for majors who actually have more than zero students enrolled:

```{r}
nStudents[nStudents > 0]
```

**6.** Get information for majors who have more students enrolled than the average enrollment number. 
(Hint: you can use the function `mean()` to get the average of a vectors' values.)

```{r}

```

**7. Create your own function to calculate the median of a vector.**
(Hint: You might need the `sort()` and `length()` functions for this. You can also find inspiration in the `is.even()` function we defined above.)

```{r}
myMedian <- function(x){

}
```

**Bonus.** Create your own function for the mode as well.
(Hint: Take a look at the `table()` function.)

**8.** Suppose the number of Physics students is not zero, but it's actually unknown (`NA` is the value used to denote in R that a value is missing or unknown).

```{r}
nStudents["Physics"] <- NA
```

**8a. (Bonus)** Get the missing values from the `nStudents` vector.
(Hint: You might want to use the `which()` and `is.na()` functions.)

```{r}

```

# Vectorization

Most functions in R can be applied to a vector in the same way they are applied to a single value.

Consider the following vector of prices:

```{r}
prices <- c(AtlSuper = 8.99, Sobeys = 9.4, Arthurs = 9.2, Lawtons = 7.8)
```

If we want to add the VAT to the prices, we can just do the following:

```{r}
1.1 * prices
```

Each element of the vector was multiplied by 1.1.

**1. Create a function** that, given a vector of prices and a VAT rate, adds the VAT to a vector of prices.

```{r}
addVAT <- 
```

Since the function you created relies on multiplication, which is "vectorizable", the function will be as well, i.e., you can apply it to a vector and it will apply to each element in the vector.

Suppose we know the prices of this product in a different city:

```{r}
prices2 <- c(AtlSuper = 7.6, Sobeys = 11.0, Arthurs = 10.5, Lawtons = 8.2)
```

We can get the mean price by running the following chunk of code:

```{r}
(prices + prices2)/2
```

Each element of the first vector is added to the corresponding position in the second vector.

**2.** What happens if we change the order of the information in the second vector?

```{r}
prices2 <- prices2[c("Sobeys", "AtlSuper", "Arthurs", "Lawtons")]

(prices + prices2)/2
```

The sum does not use the vector names to match before summing. It is purely based on the order of the values.

**3.** What if the second city does not have an Arthur's Market?

```{r}
prices2 <- prices2[-which(names(prices2) == "Arthurs")]

(prices + prices2)/2
```

The values in prices2 get recycled, so the first element in `prices2` gets added to the last in `prices`, and you only get a warning about the vector sizes not matching.

**4.** What if the second city does not have a Lawton's either?

```{r}
prices2 <- c(AtlSuper = 7.6, Sobeys = 11.0)

(prices + prices2)/2
```

The values in prices2 get recycled, so the first element in `prices2` gets added to the third in `prices`, and since the lengths are multipliers of each other, you don't get a warning.

Actually, when you multiply a vector by a single number it is exactly the same behavior that is doing the job - recycling the smaller operator until it reaches the size of the largest.

**5.** Any number is said to be a perfect number if the sum of its proper divisors (all divisors except the number in itself) is equal to that number. For instance, the sum of the proper divisors of 6, which are 1, 2 and 3, is equal to 6, thus 6 is a perfect number.

**5a.** Write a function that receives as argument one integer and returns TRUE if the number is perfect and FALSE, otherwise.
(Hints: You may find useful to check the operators `%%` and `%/%`, as well as the function `which()`)

**5b.** Write a function that receives as argument an integer and returns the numbers less than that integer that are perfect. Suggestion: re-use the function you have developed in the previous question.
(Hint: you may find useful to learn about the function `sapply()`)

# Matrices

Like vectors, matrices in R store values of the same data type. You can create a matrix with the number of smokers per location and age like this:

```{r}
smk <- matrix(c(45, 55, 56.4, 43.6, 63.2, 36.8), nrow = 2, ncol = 3)
smk
```

Like with vectors, you can set the column and row names to facilitate access to certain values.

```{r}
rownames(smk) <- c("adults", "seniors")
colnames(smk) <- c("Lisbon", "Porto", "Faro")
smk
```

```{r}
smk["seniors", "Lisbon"]
```

```{r}
smk[ , "Faro"]
```

```{r}
smk["seniors", ]
```

Using names is useful for visualization just like it was with vectors:

```{r}
barplot(smk, legend.text = TRUE)
```

Vectorization also works with matrices.

Suppose you want to have this value to range from 0 to 1 instead of 0 to 100, you can do:

```{r}
smk/100
```

If you want the global average, you can just do:

```{r}
mean(smk)
```

You can index the row or column in the matrix to get averages in a specific location or age bracket.

```{r}
mean(smk["adults", ])
```

```{r}
mean(smk[ , "Porto"])
```

If we had many more locations, it would be hard to do this by hand. You can use the `apply()` function instead.

```{r}
apply(smk, 2, mean)
```


The `apply()` function can be used to apply any other function to any of the dimensions (check its help page), of any multi-dimensional R object. 
Note that we got a useful vector with proper names as result!


# Data Frames

Data frames are the structure we most often used to store data tables. Unlike matrices, it data frames do not require the stored values to be all of the same data type (though each column can only contain values of a single data type).

```{r}
sales <- data.frame(prod = c("p1", "p2", "p1", "p3", "p2", "p1"), salesperson = c("Ana", "Ana", "Carlos", "Ana", "Carlos", "John"), quant = c(1043, 4300, 2332, 3320, 3323, 1200))
```

You can access information in a similar way to matrices.

```{r}
sales[2,3]
```

```{r}
sales[,"quant"]
```

```{r}
sales[2, "salesperson"]
```

On the last example the answer may be a bit surprising, namely the information after the word Levels. R stores the columns containing textual information in a special form. R uses a data structure named a factor to store the content of categorical variables. Factors are data structures that allow a more efficient form of storing this type of information. Factors have a set of possible values (the levels). This is the information shown on the query above. Several R functions take advantage of factors to provide more meaningful results (e.g. counting occurrences, graph axes labels, etc.).

You can use the function `subset()` to to query the data in a data frame in a similar way to SQL queries.

```{r}
subset(sales, salesperson == "Ana")
```

```{r}
subset(sales, quant > 3000, prod)
```

```{r}
subset(sales, prod == "p1" & quant < 4000, c(salesperson, quant))
```

Indexing in data frames can also be done though a more “standard” way, i.e. without the help of a function. Namely, you may add restrictions on both the rows and the columns of the data frame, producing effects similar to those obtained above with the subset() function. This method may even be more flexible at stages.

```{r}
sales[sales$salesperson == "Ana", ]
```

```{r}
sales[sales$quant > 3000, "prod"]
```

```{r}
sales[sales$prod == "p1" & sales$quant < 4000, c("salesperson", "quant")]
```

Operator `$` refers to a column, e.g., `sales$prod` represents the values of the column `prod`, and we could equivalently use `sales[ , "prod"]` instead, although that is not so practical.

Notice that when you index a single column the output is a vector. If you want to keep it as a single-column data frame, you have to use the `drop` argument.

```{r}
sales[ , "salesperson", drop = FALSE]
```

For very large data frames the function `str()` is sometimes useful to have an overall idea of the data set.

```{r}
str(sales)
```

We may also see the first lines of any data frame (useful for large objects) using the function `head()` (there is also `tail()` for the last rows),

```{r}
head(sales)
```

R (and a lot of extra packages that you may install) already contain several data sets that can be used to play around with the available functions. 

Knowing the name of one of such data sets we can easily "load" it using the function `data()`. If we call this function without any argument (simply opening and closing the parentheses) we will get a list of the available data sets for us to use. We can then use `? <name of the data set>` to obtain further information on the data.

```{r}
data(iris)
str(iris)
```

**1.** Load in the data set named “Boston” that comes with the package MASS. This data set describes the median house price in 506 different regions of Boston. You may load the data doing: `data(Boston,package='MASS')`. This should create a data frame named Boston. You may know more about this data set doing `help(Boston,package='MASS')`. With respect to this data answer the following questions:

- *(a)* Obtain a summary of the basic statistical properties of the data set.
- *(b)* What are the data on the regions with a median price higher than 45?
- *(c)* What are the values of nox and tax for the regions with an average number of rooms (rm) above 8?
- *(d)* Which regions have an average median price between 10 and 15? What is the inter-quartile range of nox in those regions?
- *(e)* What is the average criminality rate (crim) for the regions with a number of rooms above 6? And the standard deviation?
- *(f)* The variable chas indicates whether the region is on the margin of the Charles river or not (values 1 and 0, respectively). Produce a graph showing the distribution of the prices according to this variable. Can you draw any conclusion from this graph?
- *(g)* Are there any outliers in the value (medv) of the homes?
(Hint: Use function `boxplot.stats`)

**Bonus 1.** Create your own function that, given a vector of values, outputs the outliers according to the boxplot rule you learned in class.

```{r}
bpRule <- function(x){
  
}
```

**Bonus 2.** Add an argument to the function that lets you set whether you would like to ouptut the positions of the outliers instead of their values.


# References

Torgo, L. (2021). Foundations of Data Science using R Lab Notes n. 1 - R Basic Concepts. Dalhousie University.




